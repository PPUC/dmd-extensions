name: Build and Package

on: [push]

permissions:
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    permissions:
      packages: write
      contents: read
    strategy:
      matrix:
        platform: [x86, x64]
        configuration: [Release]
    env:
      NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Add dotnet
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2.0.1

      - uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}\.nuget\packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Download and Setup VPinMAME
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "https://github.com/freezy/dmd-extensions/files/4073824/VPinMAME31_Minimal.zip" -OutFile vpm.zip
          Expand-Archive vpm.zip -DestinationPath vpm
          cd vpm
          regsvr32 /s VPinMAME.dll
          cd ..

      - name: Restore NuGet packages
        run: nuget restore DmdExtensions.sln

      - name: Restore DLLExport dependency
        run: .\DllExport -action Restore -sln-file DmdExtensions.sln

      - name: Update version info
        id: set_version
        shell: pwsh
        run: |
          function replaceNumericVersion($name, $fileContent) {
            $RegularExpression = [regex] "^[^/]*\[assembly:\s*$name\(\""(\d+)\.(\d+)\.(\d+)(\.(\d+))?\""\)"
            foreach($content in $fileContent) {
              $match = [System.Text.RegularExpressions.Regex]::Match($content, $RegularExpression)
              if ($match.Success) {
                $major=$match.groups[1].value -as [int]
                $minor=$match.groups[2].value -as [int]
                $patch=$match.groups[3].value -as [int]
                return $fileContent -replace "^[^/]*\[assembly:\s*$name\(\""[^""]*\""\)", "[assembly: $name(""$major.$minor.$patch.$env:GITHUB_RUN_NUMBER"")]".TrimEnd("]")  # remove trailing ]
              }
            }
          }

          function replaceFullVersion($name, $fileContent) {
            $RegularExpression = [regex] "[^/]*\[assembly:\s*$name\(\""(\d)\.(\d)\.(\d)(-([\w\W]+))?\""\)"
            foreach($content in $fileContent) {
              $match = [System.Text.RegularExpressions.Regex]::Match($content, $RegularExpression)
              if ($match.Success) {
                $major=$match.groups[1].value -as [int]
                $minor=$match.groups[2].value -as [int]
                $patch=$match.groups[3].value -as [int]
                $tag=$match.groups[5].value

                $branch = if ($env:GITHUB_HEAD_REF) { $env:GITHUB_HEAD_REF } else { $env:GITHUB_REF_NAME }
                if ($branch -eq "master" -or $branch -eq "main") {
                  if ($tag) { $version = "$major.$minor.$patch-$tag-r$env:GITHUB_RUN_NUMBER" }
                  else { $version = "$major.$minor.$patch-r$env:GITHUB_RUN_NUMBER" }
                } else {
                  $version = "$major.$minor.$patch-$($branch.ToUpper())-r$env:GITHUB_RUN_NUMBER"
                }

                "version=$version" >> $env:GITHUB_OUTPUT
                return $fileContent -replace "^[^/]*\[assembly:\s*$name\(\""[^""]*\""\)", "[assembly: $name(""$version"")]".TrimEnd("]")
              }
            }
          }

          function replaceAny($name, $replaceWith, $fileContent) {
            $RegularExpression = [regex] "^[^/]*\[assembly:\s*$name\(\""[^""]*\""\)"
            foreach($content in $fileContent) {
              $match = [System.Text.RegularExpressions.Regex]::Match($content, $RegularExpression)
              if ($match.Success) {
                return $fileContent -replace "^[^/]*\[assembly:\s*$name\(\""[^""]*\""\)", "[assembly: $name(""$replaceWith"")]".TrimEnd("]")
              }
            }
          }

          $assemblyFile = "VersionAssemblyInfo.cs"
          $fileContent = Get-Content $assemblyFile
          $fileContent = replaceNumericVersion 'AssemblyVersion' $fileContent
          $fileContent = replaceNumericVersion 'AssemblyFileVersion' $fileContent
          $fileContent = replaceFullVersion 'AssemblyInformationalVersion' $fileContent
          if (-not $env:GITHUB_REF.StartsWith("refs/tags/")) {
            $fileContent = replaceAny 'AssemblyConfiguration' $env:GITHUB_SHA.Substring(0, 7) $fileContent
          }
          $fileContent | Set-Content "$assemblyFile"

      - name: Build
        run: msbuild -t:rebuild /p:Platform=${{ matrix.platform }} /p:Configuration=${{ matrix.configuration }} DmdExtensions.sln

      - name: Build installer
        run: msbuild /p:Platform=${{ matrix.platform }} /p:Configuration=${{ matrix.configuration }} /p:SolutionDir="$env:GITHUB_WORKSPACE\" .\Installer\Installer.wixproj

      - name: Package .zip with versioned filename
        shell: pwsh
        run: |
          $version = "${{ steps.set_version.outputs.version }}"
          $outDir  = "$env:GITHUB_WORKSPACE\Installer\Builds"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          $zipArchive = Join-Path $outDir "dmdext-v$version-${{ matrix.platform }}.zip"

          Compress-Archive -Path "$env:GITHUB_WORKSPACE\Console\bin\${{ matrix.platform }}\${{ matrix.configuration }}\dmdext.exe" -DestinationPath $zipArchive -Force
          Compress-Archive -Path "$env:GITHUB_WORKSPACE\Console\bin\${{ matrix.platform }}\${{ matrix.configuration }}\dmdext.log.config" -Update -DestinationPath $zipArchive
          Compress-Archive -Path "$env:GITHUB_WORKSPACE\Console\ProPinballSlave.bat" -Update -DestinationPath $zipArchive

          $dllSuffix = if ('${{ matrix.platform }}' -eq 'x64') { '64' } else { '' }
          Compress-Archive -Path "$env:GITHUB_WORKSPACE\PinMameDevice\bin\${{ matrix.platform }}\${{ matrix.configuration }}\DmdDevice$dllSuffix.dll" -Update -DestinationPath $zipArchive
          Compress-Archive -Path "$env:GITHUB_WORKSPACE\PinMameDevice\bin\${{ matrix.platform }}\${{ matrix.configuration }}\DmdDevice.log.config" -Update -DestinationPath $zipArchive

          # add ini template as folder (no nested zip)
          $iniTemp = "$env:GITHUB_WORKSPACE\ini-template"
          New-Item -Type Directory -Force $iniTemp | Out-Null
          Copy-Item -Path "$env:GITHUB_WORKSPACE\PinMameDevice\DmdDevice.ini" -Destination $iniTemp
          Compress-Archive -Path "$iniTemp\*" -Update -DestinationPath $zipArchive
          Remove-Item $iniTemp -Recurse -Force

          # include data folder contents as 'dmdext' directory
          Rename-Item "$env:GITHUB_WORKSPACE\PinMameDevice\data" "$env:GITHUB_WORKSPACE\PinMameDevice\dmdext"
          Compress-Archive -Path "$env:GITHUB_WORKSPACE\PinMameDevice\dmdext\*" -Update -DestinationPath $zipArchive
          Rename-Item "$env:GITHUB_WORKSPACE\PinMameDevice\dmdext" "$env:GITHUB_WORKSPACE\PinMameDevice\data"

      - name: Rename MSI to versioned filename
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $version = "${{ steps.set_version.outputs.version }}"
          $root    = $env:GITHUB_WORKSPACE
          $outDir  = Join-Path $root 'Installer\Builds'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          # Look for the latest MSI in common WiX output locations
          $searchRoots = @(
            (Join-Path $root 'Installer\Builds'),
            (Join-Path $root 'Installer\bin'),
            (Join-Path $root 'Installer') # fallback
          ) | Get-Unique

          $candidates = @()
          foreach ($dir in $searchRoots) {
            if (Test-Path $dir) {
              $candidates += Get-ChildItem -Path $dir -Filter *.msi -File -Recurse -ErrorAction SilentlyContinue
            }
          }

          if (-not $candidates -or $candidates.Count -eq 0) {
            throw "No MSI found under: `n  - $($searchRoots -join "`n  - ")"
          }

          # Pick the most recently written MSI
          $msi = $candidates | Sort-Object LastWriteTimeUtc -Descending | Select-Object -First 1

          $target = Join-Path $outDir "dmdext-v$version-${{ matrix.platform }}.msi"

          if ($msi.FullName -ieq $target) {
            Write-Host "MSI already has the correct name: $target"
            exit 0
          }

          # Copy to the target name (more reliable on hosted runners), then remove the original
          Copy-Item -Path $msi.FullName -Destination $target -Force
          if (-not (Test-Path $target)) {
            throw "Failed to create target MSI at: $target"
          }

          # Clean up the original if it lives elsewhere
          if ($msi.FullName -ne $target) {
            Remove-Item -Path $msi.FullName -Force
          }

          Write-Host "MSI placed at: $target"

      # Upload the already-zipped bundle WITHOUT re-compressing
      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: dmdext-v${{ steps.set_version.outputs.version }}-${{ matrix.platform }}.zip
          path: ${{ github.workspace }}\Installer\Builds\dmdext-v${{ steps.set_version.outputs.version }}-${{ matrix.platform }}.zip
          compression-level: 0
          retention-days: 90
          if-no-files-found: error

      # Upload the MSI as-is (not zipped)
      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: dmdext-v${{ steps.set_version.outputs.version }}-${{ matrix.platform }}.msi
          path: ${{ github.workspace }}\Installer\Builds\dmdext-v${{ steps.set_version.outputs.version }}-${{ matrix.platform }}.msi
          compression-level: 0
          retention-days: 90
          if-no-files-found: error
