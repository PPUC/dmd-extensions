using System;
using System.Collections.Generic;
using System.IO;
using System.Reactive;
using System.Reactive.Subjects;
using System.Runtime.InteropServices;
using System.Windows.Media;
using LibDmd.Common;
using LibDmd.DmdDevice;
using LibDmd.Frame;
using LibDmd.Input;
using LibDmd.Output.PinUp;
using NLog;

namespace LibDmd.Converter.Plugin
{
	public class ColorizationPlugin : AbstractSource, IConverter, IColoredGray6Source
	{
		public override string Name => "Colorization Plugin";
		public FrameFormat From => FrameFormat.Gray2;

		public IObservable<ColoredFrame> GetColoredGray6Frames() => _coloredGray6Frames;

		public IObservable<Unit> OnResume => null;
		public IObservable<Unit> OnPause => null;

		private Dimensions _dimensions = new Dimensions(128, 32);

		public bool IsEnabled { get; private set; }

		/// <summary>
		/// Whether frames should be sent to the plugin.
		/// </summary>
		public bool ReceiveFrames => _isOpen;

		/// <summary>
		/// Whether frames are generated by the plugin.
		/// </summary>
		public bool SendFrames => IsColoring;

		/// <summary>
		/// DLL has been initialized (Open returned true).
		/// </summary>
		private bool _isOpen;

		/// <summary>
		/// Whether the plugin has found colorization data and will output colored frames.
		/// </summary>
		private bool IsColoring => _colorizerMode >= 0;

		/// <summary>
		/// If true, the plugin has events that should be sent to PinUp.
		/// </summary>
		private bool _hasEvents;

		private readonly Subject<ColoredFrame> _coloredGray6Frames = new Subject<ColoredFrame>();
		private readonly bool _scaleToHd;

		private uint _lastEventId;
		private ColorizerMode _colorizerMode;
		private PinUpOutput _activePinUpOutput;

		private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

		public ColorizationPlugin(string pluginPath, bool colorize, string altcolorPath, string gameName, Color defaultColor, IReadOnlyList<Color> defaultPalette, bool scaleToHd) {

			this._scaleToHd = scaleToHd;

			// load plugin
			if (!LoadPlugin(pluginPath)) {
				return;
			}

			// open plugin
			if (!_open()) {
				Logger.Info("[plugin] Failed to open colorizer plugin.");
				return;
			}
			_isOpen = true;
			Logger.Info($"[plugin] Successfully opened colorizer plugin at {pluginPath}");

			// configure plugin
			_setAltColorPath(altcolorPath);
			PMoptions options = new PMoptions { Red = defaultColor.R, Green = defaultColor.G, Blue = defaultColor.B, Colorize = colorize ? 1 : 0 };
			IntPtr optionsPtr = Marshal.AllocHGlobal(Marshal.SizeOf(options));
			Marshal.StructureToPtr(options, optionsPtr, false);
			_colorizerMode = (ColorizerMode)_setGameSettings(gameName, 0, optionsPtr);
			if (_colorizerMode >= 0) {
				_hasEvents = _hasEventsPtr();

				// dmd frames might return upscaled, so adapt size accordingly
				switch (_colorizerMode) {
					case ColorizerMode.Advanced192x64:
						_dimensions = new Dimensions(192, 64);
						break;
					case ColorizerMode.Advanced256x64:
						_dimensions = new Dimensions(256, 64);
						break;
					case ColorizerMode.Advanced128x32:
					case ColorizerMode.None:
					case ColorizerMode.SimplePalette:
						// no dimension changes
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}

				IsEnabled = true;
				Logger.Info($"[plugin] Colorization mode {_colorizerMode.ToString()} enabled.");

			} else {

				// relay palette from VPM to plugin
				var pal = new byte[defaultPalette.Count * 3];
				for (int i = 0; i < defaultPalette.Count; i++) {
					pal[i * 3] = defaultPalette[i].R;
					pal[(i * 3) + 1] = defaultPalette[i].G;
					pal[(i * 3) + 2] = defaultPalette[i].B;
				}
				switch (defaultPalette.Count) {
					case 4:
						_set4Colors(pal);
						break;
					case 16:
						_set16Colors(pal);
						break;
				}
				Logger.Info("[plugin] No colorization mode detected, disabled.");
			}
		}
		public void Init()
		{
		}

		public void Dispose()
		{
			if (_isOpen) {
				_activePinUpOutput = null;
				_hasEvents = false;
				_close();
			}

			_colorizerMode = ColorizerMode.None;
			_isOpen = false;
		}

		public string GetVersion()
		{
			IntPtr pointer = _getVersion();
			string str = Marshal.PtrToStringAnsi(pointer);
			return str;
		}

		public string GetName()
		{
			IntPtr pointer = _getName();
			string str = Marshal.PtrToStringAnsi(pointer);
			return str;
		}

		public void ConsoleData(byte data)
		{
			_onConsoleData(data);
		}

		private void ProcessEvent()
		{
			if (_activePinUpOutput == null) {
				return;
			}

			uint eventId = _getEvent();
			if (eventId == _lastEventId) {
				return;
			}

			_lastEventId = eventId;
			_activePinUpOutput.SendTriggerID((ushort)eventId);
		}

		public void SetPinUpOutput(PinUpOutput puo)
		{
			_activePinUpOutput = puo;
			if ((puo != null) && _hasEvents) {
				puo.PuPFrameMatching = false;
			}
		}

		#region Conversion

		private byte[] _frame;
		private readonly Dictionary<int, int> _colorIndex = new Dictionary<int, int>();
		private readonly Color[] _palette = new Color[64];

		/// <summary>
		/// The public API to convert a frame and output it to the pubs.
		/// </summary>
		/// <param name="frame">Uncolored frame with in <see cref="FrameFormat"/>.</param>
		public void Convert(DmdFrame frame)
		{
			var frameSize = _dimensions.Surface * 3;
			var coloredFrame = new byte[frameSize];

			if (!_isOpen) {
				return;
			}

			IntPtr rgb24FramePtr = IntPtr.Zero;

			// raw (bit plane) conversion
			if (frame is RawFrame rawFrame && rawFrame.RawPlanes.Length > 0) {
				var rawBuffer = new byte[rawFrame.RawPlanes.Length * rawFrame.RawPlanes[0].Length];
				for (int i = 0; i < rawFrame.RawPlanes.Length; i++) {
					rawFrame.RawPlanes[i].CopyTo(rawBuffer, i * rawFrame.RawPlanes[0].Length);
				}

				// 4 bit planes
				if (frame.BitLength == 4) {
					switch (frame.Data.Length) {
						case 128 * 32:
							rgb24FramePtr = _colorizeGray4Raw(128, 32, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
						case 192 * 64:
							rgb24FramePtr = _colorizeGray4Raw(192, 64, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
						case 256 * 64:
							rgb24FramePtr = _colorizeGray4Raw(256, 64, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
					}
					if (IsColoring)
						Marshal.Copy(rgb24FramePtr, coloredFrame, 0, frameSize);

				}
				// 2 bit planes
				else {
					switch (frame.Data.Length) {
						case 128 * 32:
							rgb24FramePtr = _colorizeGray2Raw(128, 32, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
						case 192 * 64:
							rgb24FramePtr = _colorizeGray2Raw(192, 64, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
						case 256 * 64:
							rgb24FramePtr = _colorizeGray2Raw(256, 64, frame.Data, (ushort)rawFrame.RawPlanes.Length, rawBuffer);
							break;
					}
					if (_colorizerMode != ColorizerMode.None)
						Marshal.Copy(rgb24FramePtr, coloredFrame, 0, frameSize);
				}
			}
			// non-raw conversion
			else {

				// 4 bit data
				if (frame.BitLength == 4) {
					switch (frame.Data.Length) {
						case 128 * 32:
							rgb24FramePtr = _colorizeGray4(128, 32, frame.Data);
							break;
						case 192 * 64:
							rgb24FramePtr = _colorizeGray4(192, 64, frame.Data);
							break;
						case 256 * 64:
							rgb24FramePtr = _colorizeGray4(256, 64, frame.Data);
							break;
					}
					if (_colorizerMode != ColorizerMode.None)
						Marshal.Copy(rgb24FramePtr, coloredFrame, 0, frameSize);

				}
				// 2 bit data
				else if (frame.BitLength == 2) {
					switch (frame.Data.Length) {
						case 128 * 16:
							rgb24FramePtr = _colorizeGray2(128, 16, frame.Data);
							break;
						case 128 * 32:
							rgb24FramePtr = _colorizeGray2(128, 32, frame.Data);
							break;
						case 192 * 64:
							rgb24FramePtr = _colorizeGray2(192, 64, frame.Data);
							break;
						case 256 * 64:
							rgb24FramePtr = _colorizeGray2(256, 64, frame.Data);
							break;
					}
					if (_colorizerMode != ColorizerMode.None)
						Marshal.Copy(rgb24FramePtr, coloredFrame, 0, frameSize);

				}
				// rgb24 data
				else {
					_colorizeRgb24((ushort)frame.Dimensions.Width, (ushort)frame.Dimensions.Height, frame.Data);
					return;
				}
			}

			if (_colorizerMode == ColorizerMode.None) {
				return;
			}

			//var width = Width;
			//var height = Height;
			//if (_scaleToHd && width == 128 && height == 32) {
			//	width = 256;
			//	height = 64;
			//}

			EmitFrame(_dimensions, coloredFrame);
			ProcessEvent();
		}

		public void Convert(AlphaNumericFrame frame)
		{
			int width = 128;
			int height = 32;

			var frameSize = width * height * 3;
			var coloredFrame = new byte[frameSize];

			var rgb24Buffer = _colorizeAlphaNumeric(frame.SegmentLayout, frame.SegmentData, frame.SegmentDataExtended);
			if (_colorizerMode == ColorizerMode.None) {
				return;
			}

			Marshal.Copy(rgb24Buffer, coloredFrame, 0, frameSize);
			if (_scaleToHd) {
				width *= 2;
				height *= 2;
			}

			EmitFrame(new Dimensions(width, height), coloredFrame);
			ProcessEvent();
		}

		private void EmitFrame(Dimensions dim, IReadOnlyList<byte> rgb24Frame)
		{
			if (_frame == null || _frame.Length != dim.Surface) {
				_frame = new byte[dim.Surface];
			}
			_colorIndex.Clear();
			for (var k = 0; k < 64; k++) {
				_palette[k] = Colors.Black;
			}

			var len = dim.Surface * 3;
			var lastIndex = -1;
			var j = 0;
			for (var i = 0; i < len; i += 3) {
				var color = rgb24Frame[i] << 16 | rgb24Frame[i + 1] << 8 | rgb24Frame[i + 2];
				int index;
				if (!_colorIndex.ContainsKey(color)) {
					lastIndex++;
					_colorIndex[color] = lastIndex;
					_palette[lastIndex] = Color.FromRgb(rgb24Frame[i], rgb24Frame[i + 1], rgb24Frame[i + 2]);
					index = lastIndex;
				} else {
					index = _colorIndex[color];
				}
				_frame[j++] = (byte)index;
			}

			// split and send
			var planes = FrameUtil.Split(dim, 6, _frame);
			_coloredGray6Frames.OnNext(new ColoredFrame(dim, planes, _palette));
		}

		#endregion

		#region Plugin API

		private bool LoadPlugin(string dllPath)
		{
			if (!File.Exists(dllPath)) {
				Logger.Error("[plugin] Ignoring plugin defined at " + dllPath + ", file does not exist.");
				return false;
			}

			var dll = NativeDllLoad.LoadLibrary(dllPath);
			if (dll == IntPtr.Zero) {
				Logger.Error("[plugin] Error loading plugin at " + dllPath + ".");
				return false;
			}

			// Now load function calls using PinMame BSD-3 licensed DmdDevice.DLL API
			// See README.MD in PinMameDevice folder.
			try {
				var addr = NativeDllLoad.GetProcAddress(dll, "Open");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Open in " + dllPath);
				}
				_open = (OpenPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(OpenPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "PM_GameSettings");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function PM_GameSettings in " + dllPath);
				}
				_setGameSettings = (SetGameSettingsPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(SetGameSettingsPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_4_Shades");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_4_Shades in " + dllPath);
				}
				_colorizeGray2 = (ColorizeGray2Ptr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeGray2Ptr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_16_Shades");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_16_Shades in " + dllPath);
				}
				_colorizeGray4 = (ColorizeGray4Ptr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeGray4Ptr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_4_Shades_with_Raw");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_4_Shades_with_Raw in " + dllPath);
				}
				_colorizeGray2Raw = (ColorizeGray2RawPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeGray2RawPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_16_Shades_with_Raw");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_16_Shades_with_Raw in " + dllPath);
				}
				_colorizeGray4Raw = (ColorizeGray4RawPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeGray4RawPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_RGB24");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_RGB24 in " + dllPath);
				}
				_colorizeRgb24 = (ColorizeRgb24Ptr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeRgb24Ptr));

				addr = NativeDllLoad.GetProcAddress(dll, "Render_PM_Alphanumeric_Frame");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Render_PM_Alphanumeric_Frame in " + dllPath);
				}
				_colorizeAlphaNumeric = (ColorizeAlphaNumericPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ColorizeAlphaNumericPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Close");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Close in " + dllPath);
				}
				_close = (ClosePtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(ClosePtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Console_Data");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Console_Data in " + dllPath);
				}
				_onConsoleData = (OnConsoleDataPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(OnConsoleDataPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Set_4_Colors_Palette");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Set_4_Colors_Palette in " + dllPath);
				}
				_set4Colors = (Set4ColorsPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(Set4ColorsPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Set_16_Colors_Palette");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Set_16_Colors_Palette in " + dllPath);
				}
				_set16Colors = (Set16ColorsPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(Set16ColorsPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Get_Event");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Get_Event in " + dllPath);
				}
				_getEvent = (GetEventPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(GetEventPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Has_Events");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Has_Events in " + dllPath);
				}
				_hasEventsPtr = (HasEventsPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(HasEventsPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "PM_AltColorPath");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function PM_AltColorPath in " + dllPath);
				}
				_setAltColorPath = (SetAltColorPathPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(SetAltColorPathPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Get_Version");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Get_Version in " + dllPath);
				}
				_getVersion = (GetVersionPtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(GetVersionPtr));

				addr = NativeDllLoad.GetProcAddress(dll, "Get_Name");
				if (addr == IntPtr.Zero) {
					throw new Exception("Cannot map function Get_Name in " + dllPath);
				}
				_getName = (GetNamePtr)Marshal.GetDelegateForFunctionPointer(addr, typeof(GetNamePtr));

			} catch (Exception e) {
				Logger.Error($"Error loading plugin, disabling: {e.Message}");
				return false;
			}
			return true;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate bool OpenPtr();
		private OpenPtr _open;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void Set4ColorsPtr(byte[] palette);
		private Set4ColorsPtr _set4Colors;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void Set16ColorsPtr(byte[] palette);
		private Set16ColorsPtr _set16Colors;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr ColorizeGray4Ptr(ushort width, ushort height, byte[] currBuffer);
		private ColorizeGray4Ptr _colorizeGray4;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr ColorizeGray2Ptr(ushort width, ushort height, byte[] currBuffer);
		private ColorizeGray2Ptr _colorizeGray2;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr ColorizeGray4RawPtr(ushort width, ushort height, byte[] currBuffer, ushort numRawFrames, byte[] currRawBuffer);
		private ColorizeGray4RawPtr _colorizeGray4Raw;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr ColorizeGray2RawPtr(ushort width, ushort height, byte[] currBuffer, ushort numRawFrames, byte[] currRawBuffer);
		private ColorizeGray2RawPtr _colorizeGray2Raw;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void ColorizeRgb24Ptr(ushort width, ushort height, byte[] currBuffer);
		private ColorizeRgb24Ptr _colorizeRgb24;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr ColorizeAlphaNumericPtr(NumericalLayout numericalLayout, ushort[] segData, ushort[] segData2);
		private ColorizeAlphaNumericPtr _colorizeAlphaNumeric;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int SetGameSettingsPtr(string gameName, ulong hardwareGeneration, IntPtr options);
		private SetGameSettingsPtr _setGameSettings;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate bool ClosePtr();
		private ClosePtr _close;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConsoleDataPtr(byte data);
		private OnConsoleDataPtr _onConsoleData;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate uint GetEventPtr();
		private GetEventPtr _getEvent;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate bool HasEventsPtr();
		private HasEventsPtr _hasEventsPtr;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void SetAltColorPathPtr(string path);
		private SetAltColorPathPtr _setAltColorPath;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr GetVersionPtr();
		private GetVersionPtr _getVersion;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate IntPtr GetNamePtr();
		private GetNamePtr _getName;

		#endregion
	}
	
	public enum ColorizerMode
	{
		None = -1,
		SimplePalette = 0,
		Advanced128x32 = 1,
		Advanced192x64 = 3,
		Advanced256x64 = 4,
	}
	
	static class NativeDllLoad
	{
		[DllImport("kernel32.dll")]
		public static extern IntPtr LoadLibrary(string dllToLoad);

		[DllImport("kernel32.dll")]
		public static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);

		[DllImport("kernel32.dll")]
		public static extern bool FreeLibrary(IntPtr hModule);
	}
}
